Using Conversion Functions and Conditional Expressions

Conversion Functions (用來變更資料型態)
1. The data type conversion can be done implicily by the Oracle server or
                                        ^^^^^^^^^
   explicily by the user.
   ^^^^^^^^^
   1.1. Implicily data type conversions work according to the rules.
   1.2. Explicily data type conversions are performed by using the conversion 
        functions.
        
2. Implicily Data Type Conversion
   2.1. Oracle server can automatically perform data type conversion in an 
        expression.
        A VARCHAR2 or CHAR value can be implicitly converted to a number or date
        data type in an expression.
        ════════════════════════════════════════════════════════════════════════
        From                 To
        ────────────────────────────────────────────────────────────────────────
        VARCHAR2 or CHAR     NUMBER
        VARCHAR2 or CHAR     DATE
        ════════════════════════════════════════════════════════════════════════
        Example:
            the expression hire_date > '01-JAN-90' results in the implicit 
            conversion from the string '01-JAN-90' to a date.
   2.2. Oracle server uses the rule for expressions when a data type conversion 
        is needed.
        ════════════════════════════════════════════════════════════════════════
        From       To
        ────────────────────────────────────────────────────────────────────────
        NUMBER     VARCHAR2 or CHAR
        DATE       VARCHAR2 or CHAR
        ════════════════════════════════════════════════════════════════════════
        Example:
            the expression grade = 2 results in the implicit conversion of the 
            number 2 to the string "2" because grade is a CHAR(2) column.
   <補充>
        SQL> SELECT 1||1 FROM dual; -- 因為使用||連接,所以自動(隱式implicit)將1使
                                       用TO_CHAR轉成文字1後,才連結在一起
                                    -- 等同SELECT TO_CHAR(1)||TO_CHAR(1) FROM dual;
        1|   --column heading靠左邊對齊,表示此欄位值為文字或日期
        --
        11   --column heading靠左邊對齊,表示此欄位值為文字或日期

        SQL> SELECT 1+1 FROM dual;
        
               1+1    -- column heading靠右邊對齊,表示此欄位值為數字
        ----------
                 2    -- 欄位值靠右對齊,表示此欄位值為數字
        
        SQL> SELECT '1'+1 FROM dual; -- 因為使用+,所以自動使用TO_NUMBER將'1'轉成
                                        數字1後(implicit conversion),才進行相加
        
             '1'+1
        ----------
                 2
        
        SQL> SELECT '$1'+1 FROM dual;
        SELECT '$1'+1 FROM dual
               *
         ERROR 在行 1:
        ORA-01722: 無效的數字  -- 隱式型別轉換TO_NUMBER失敗,因為預設的format 
                                  model無法解析$1.

3. Explicit Data Type Conversion
     ┌──TO_NUMBER──┐ ┌───TO_DATE───┐
     ↓             │ │             ↓
   NUMMBER        CHARACTER        DATE
     │             ↑ ↑             │
     └──TO_CHAR────┘ └───TO_CHAR───┘
   3.1. Using the TO_CHAR Function with Dates
   
        TO_CHAR( date, 'format_model' )
        
        TO_CHAR converts a datetime data type to a value of VARCHAR2 data type 
        in the format specified by the format_model.
        Examples:
            SELECT employee_id, TO_CHAR( hire_date, 'MM/YY') Month_Hired
            FROM employees
            WHERE last_name = 'Higgins';
        
            SELECT last_name,
                   TO_CHAR( hire_date, 'fmDD Month YYYY')
            FROM employees;

            SELECT last_name,
                   TO_CHAR( hire_date, 'fmDdspth "of" Month YYYY 
                            fmHH:MI:SS AM' ) HIREDATE
            FROM employees;
   3.2. Using the TO_CHAR Function with Numbers
        
        TO_CHAR( number, 'format_model' );

        TO_CHAR translates a value of NUMBER data type to VARCHAR2 data type in 
        the format specified by the format_model.
        
        Number Format Elements
        ════════════════════════════════════════════════════════════════════════
        Element    Description                                 Example    Result
        ────────────────────────────────────────────────────────────────────────
        9          Numeric position (number of 9s              999999     1234
                   determine display width)
        0          Display leading zeros                       099999     001234
        $          Floating local currency symbol              $99999     $1234
        D          Returns the decimal character in the        99D99      99.99
                   specified position. The default is a
                   period (.).
        G          Returns the group separator in the          9G999      9,999 
                   specified position. You can specify
                   multiple group separators in a number
                   format model.
        ════════════════════════════════════════════════════════════════════════
        Examples:
           SELECT TO_CHAR(salary, '$99,999.00') SALARY
           FROM employees
           WHERE last_name = 'Ernst';

   3.3. Using the TO_NUMBER and TO_DATE Functions
        TO_NUMBER( char, 'format_model' )
        Convert a character string to a number format using the TO_NUMBER 
        function.

        TO_DATE( char, 'format_model' )
        Convert a character string to a date format using the TO_DATE function.

        These functions have an fx modifier. This modifier specifies the exact
        match for the character argument and date format model of a TO_DATE 
        function.
        -- Punctuation and quoted text in the character argument must exactly 
           match (except for case) the corresponding parts of the format model.
        -- The character argument cannot have extra blanks. Without fx, the 
           Oracle server ignores extra blanks.
        -- Numeric data in the character argument must have the same number of 
           digits as the corresponding element in the formate model. Without
           fx, the numbers in the character argument can omit leading zeros.

        Examples:
           SELECT last_name, hire_date
           FROM employees
           WHERE hire_date = TO_DATE( 'May  24, 1999', 'fxMonth DD, YYYY' );
                                           ^
           Because the fx modifier is used, an exact match is required and the 
           spaces after the word May are not recognized.

           SELECT last_name, hire_date
           FROM employees
           WHERE hire_date = TO_DATE( 'May 24, 1999', 'fxMonth DD, YYYY' );
 
   3.4. Using the TO_CHAR and TO_DATE Function with the RR Date Format
        The RR format interprets the year portion of the date from 1950 to 1999.
        Examples:
           SELECT last_name, TO_CHAR(hire_date, 'DD-Mon-YYYY' )
           FROM employees
           WHERE hire_date < TO_DATE( '01-Jan-90', 'DD-Mon-RR' );

        The following command, results in no rows being selected because the YY 
        format interprets the year portion of the date in the curret 
        century (2009).
        Examples:
           SELECT last_name, TO_CHAR(hire_date, 'DD-Mon-yyy')
           FROM employees
           WHERE TO_DATE( hire_date, 'DD-Mon-yy' ) < '01-Jan-1990';

    <補充>
        SQL> SELECT TO_NUMBER('$1','$9')+1 FROM dual;  -- 改用顯式型別轉換
                                                          TO_NUMBER

        TO_NUMBER('$1','$9')+1
        ----------------------
                             2
        
        當文字自動轉換為日期時,所使用的format model為NLS_DATE_FORMAT,
                                                     NLS_DATE_LANGUAGE
        SQL> SELECT last_name,hire_date 
          2  FROM hr.employees 
          3  WHERE department_id=100;

        LAST_NAME                 HIRE_DATE
        ------------------------- -------------------
        Greenberg                 2002-08-17:00:00:00
        Faviet                    2002-08-16:00:00:00
        Chen                      2005-09-28:00:00:00
        Sciarra                   2005-09-30:00:00:00
        Urman                     2006-03-07:00:00:00
        Popp                      2007-12-07:00:00:00
        
        已選取 6 個資料列.

        -- 顯示目前session所使用的日期相關參數值
        SQL> SELECT parameter,value 
		   2 FROM nls_session_parameters 
		   3 WHERE parameter LIKE 'NLS_DATE\_%' ESCAPE '\';
        
        PARAMETER                      VALUE
        ------------------------------ ----------------------------------------
        NLS_DATE_FORMAT                YYYY-MM-DD:HH24:MI:SS
        NLS_DATE_LANGUAGE              AMERICAN

        SQL> SELECT last_name,job_id
          2  FROM hr.employees
          3  WHERE hire_date='2002-08-17';  -- '1994-08-17'必須符合NLS_DATE_FORMAT,
		                                       不然將無法自動轉換
        
        LAST_NAME                 JOB_ID
        ------------------------- ----------
        Greenberg                 FI_MGR
        
        SQL> SELECT last_name,job_id
          2  FROM hr.employees
          3  WHERE hire_date='17-AUG-02';
        WHERE hire_date='17-AUG-02'
                        *
         ERROR 在行 3:
        ORA-01858: 在應為數值的位置發現非數值的字元  -- 因為IMPLICIT type 
                                                        conversion所使用的
                                                        data_format為'YYYY-MM-DD'
                                                     -- TO_DATE('17-AUG-02','YYYY-MM-DD:HH24:MI:SS') 

        SQL> SELECT last_name,job_id
          2  FROM hr.employees
          3  WHERE hire_date='17-08-02';  --隱式型別轉換將此文字變成2017-08-02(2017年8月2日)

        -- 當implicit type conversion失敗,則必須使用TO_DATE進行explict type conversion(顯式)
        SQL> SELECT last_name,job_id
          2  FROM hr.employees
          3  WHERE hire_date=TO_DATE('17-AUG-02','DD-MON-RR','NLS_DATE_LANGUAGE=american');  --至於要寫AUG還是8月,則需要根據NLS_DATE_LANGUAGE決定
        
        LAST_NAME                 JOB_ID
        ------------------------- ----------
        Greenberg                 FI_MGR

        SQL> SELECT last_name,salary,TO_CHAR(salary)
          2  FROM hr.employees
          3  WHERE last_name='King';
        文字/日期靠左邊		      數字靠右邊
        LAST_NAME                     SALARY TO_CHAR(SALARY)
        ------------------------- ---------- ----------------------------------------
        King                           10000 10000
        King                           24000 24000
                                                    'format model'
        SQL> SELECT last_name,salary,TO_CHAR(salary,'L999,999')  --L表示local currency(NLS_CURRENCY)
          2  FROM hr.employees
          3  WHERE last_name='King';
        
        LAST_NAME                     SALARY TO_CHAR(SALARY,'L
        ------------------------- ---------- -----------------
        King                           10000         NT$10,000
        King                           24000         NT$24,000
        
        SQL> select parameter,value from nls_session_parameters where parameter like 'NLS_CURRENCY%';
        
        PARAMETER                      VALUE
        ------------------------------ ----------------------------------------
        NLS_CURRENCY                   NT$

        SQL> ALTER SESSION SET NLS_CURRENCY=GBP;
        
        已更改階段作業.
        
        SQL> select parameter,value from nls_session_parameters where parameter like 'NLS_CURRENCY%';
        
        PARAMETER                      VALUE
        ------------------------------ ----------------------------------------
        NLS_CURRENCY                   GBP
        
        SQL> SELECT last_name,salary,TO_CHAR(salary,'L999,999')
          2  FROM employees
          3  WHERE last_name='King';
        
        LAST_NAME                     SALARY TO_CHAR(SALARY,'L9
        ------------------------- ---------- ------------------
        King                           10000          GBP10,000
        King                           24000          GBP24,000
        
        SQL> ALTER SESSION SET NLS_CURRENCY=NT$;
        
        已更改階段作業.
        
        SQL> SELECT last_name,salary,TO_CHAR(salary,'$000,000') --$就是顯示$
          2  FROM hr.employees
          3  WHERE last_name='King';
        
        LAST_NAME                     SALARY TO_CHAR(S
        ------------------------- ---------- ---------
        King                           10000  $010,000
        King                           24000  $024,000

        SQL> SELECT last_name,salary,TO_CHAR(salary,'$000G000D00')
          2  FROM hr.employees
          3  WHERE last_name='King';
        
        LAST_NAME                     SALARY TO_CHAR(SALA
        ------------------------- ---------- ------------
        King                           10000  $010,000.00   --format model出現0時,若資料位數不足,則出現0
        King                           24000  $024,000.00
        
        SQL> SELECT last_name,salary,TO_CHAR(salary,'$999G999D99')
          2  FROM hr.employees
          3  WHERE last_name='King';
        
        LAST_NAME                     SALARY TO_CHAR(SALA
        ------------------------- ---------- ------------
        King                           10000   $10,000.00  --format model出現9時,若資料位數不足,則不會顯示任何字元
        King                           24000   $24,000.00
        
        SQL> ALTER SESSION SET NLS_TERRITORY=germany;
        
        Session altered.
        
        SQL> SELECT TO_CHAR(123456,'L999,999') FROM dual;
        
        TO_CHAR(123456,'L9
        ------------------
                 €123,456

        SQL> SELECT TO_CHAR(123456,'$999,999') FROM dual;
        
        TO_CHAR(1
        ---------
         $123,456
        
        SQL> SELECT TO_CHAR(123456,'$999G999D99') FROM dual;
        
        TO_CHAR(1234
        ------------
         $123.456,00
        
        SQL> SELECT TO_CHAR(123456,'$999,999.99') FROM dual;
        
        TO_CHAR(1234
        ------------
         $123,456.00
        
        SQL> ALTER SESSION SET NLS_TERRITORY=taiwan;
        
        Session altered.
        
        SQL> SELECT TO_CHAR(123456,'$999G999D99') FROM dual;
        
        TO_CHAR(1234
        ------------
         $123,456.00

        **V後面有幾個9,就表示乘以上10的幾次方
        SQL> SELECT 1234,TO_CHAR(1234,'999,999V9'),TO_CHAR(1234,'999,999,999V99') FROM dual;
        
              1234 TO_CHAR(1 TO_CHAR(1234,'
        ---------- --------- --------------
              1234    1,2340        1,23400
        
        SQL> SELECT last_name,salary,TO_CHAR(salary,'999,999.999MI')
          2  FROM employees
          3  WHERE employee_id=100;
        
        LAST_NAME                     SALARY TO_CHAR(SALA
        ------------------------- ---------- ------------
        King                           24000  24,000.000
        
        SQL> SELECT TO_CHAR(-24000,'999,999.999MI') FROM dual;
        
        TO_CHAR(-240
        ------------
         24,000.000-
        
         SQL> SELECT TO_CHAR(-24000,'MI999,999.999') FROM dual;
        SELECT TO_CHAR(-24000,'MI999,999.999') FROM dual
                              *
         ERROR 在行 1:
        ORA-01481: 無效的數字格式模型  --MI不能變更位置
        
        SQL> SELECT TO_CHAR(24000,'999,999.999PR') FROM dual;
        
        TO_CHAR(24000
        -------------
          24,000.000
          
        SQL> SELECT TO_CHAR(-24000,'999,999.999PR') FROM dual;
        
        TO_CHAR(-2400
        -------------
         <24,000.000>
        
        SQL> SELECT TO_CHAR(-24000,'PR999,999.999') FROM dual;
        SELECT TO_CHAR(-24000,'PR999,999.999') FROM dual
                              *
         ERROR 在行 1:
        ORA-01481: 無效的數字格式模型
        
        SQL> SELECT TO_CHAR(24000,'S999,999.999') FROM dual;
        
        TO_CHAR(2400
        ------------
         +24,000.000
        
        SQL> SELECT TO_CHAR(-24000,'S999,999.999') FROM dual;
        
        TO_CHAR(-240
        ------------
         -24,000.000
        
        SQL> SELECT TO_CHAR(-24000,'999,999.999S') FROM dual;
        
        TO_CHAR(-240
        ------------
         24,000.000-
        
        SQL> SELECT TO_CHAR(24000,'999,999.999S') FROM dual;
        
        TO_CHAR(2400
        ------------
         24,000.000+

　　　　　　　　　　　　　　        D為星期幾使用數字顯示(1表示本週的第一天)
        SQL> SELECT SYSDATE,TO_CHAR(SYSDATE,'D'),TO_CHAR(SYSDATE,'DD'),TO_CHAR(SYSDATE,'DDD') FROM dual;
        
        SYSDATE             T TO TO_
        ------------------- - -- ---
        2010-04-11:16:44:20 1 11 101
        
        SQL> SELECT SYSDATE,TO_CHAR(SYSDATE,'D'),TO_CHAR(SYSDATE,'DY'),TO_CHAR(SYSDATE,'DAY') FROM dual;
        
        SYSDATE             T TO_CHA TO_CHAR(SYSDA
        ------------------- - ------ -------------
        2010-04-11:16:45:44 1 SUN    SUNDAY
                             W本月份的第幾週	　WW本年的第幾週
        SQL> SELECT SYSDATE,TO_CHAR(SYSDATE,'W'),TO_CHAR(SYSDATE,'WW') FROM dual;
        
        SYSDATE             T TO
        ------------------- - --
        2010-04-11:16:46:05 2 15
        
        Julian Day由BC 4712 1 1起算(1),每過1天加1.一直到AD 9999 12 31
        SQL> SELECT TO_CHAR(SYSDATE,'J'),TO_CHAR(SYSDATE+100,'J') FROM dual;
        
        TO_CHAR TO_CHAR
        ------- -------
        2456660 2456760  --相差100(100天)
        
        SS現在這一分鐘的第幾秒,SSSSS從午夜00:00到目前過了幾秒
        SQL> SELECT SYSDATE,TO_CHAR(SYSDATE,'SS SSSSS') FROM dual;
        
        SYSDATE             TO_CHAR(
        ------------------- --------
        2014-01-02:20:32:21 21 73941
        
        SQL> SELECT TO_CHAR(SYSDATE,'"Week" w "of" month') FROM DUAL; --format model必須被包括在單引號裡
                                                                      --如果在format model出現literal,則必須使用雙引號包括起來
        TO_CHAR(SYSDATE,'"WEEK"
        -----------------------
        Week 4 of july            --month要求顯示月份全名
        
        SQL> SELECT TO_CHAR(SYSDATE,'"Week" w "of" Month') FROM DUAL;
        
        TO_CHAR(SYSDATE,'"WEEK"
        -----------------------
        Week 4 of July           --Month=July
        
        SQL> SELECT TO_CHAR(SYSDATE,'"Week" w "of" MOnth') FROM DUAL;
        
        TO_CHAR(SYSDATE,'"WEEK"
        -----------------------
        Week 4 of JULY          --MOnth=JULY
        
        　　　　　　　　　　DD-MON-RR
        SQL> SELECT TO_DATE('11-APR-10') FROM dual;　　--直接使用NLS_DATE_FORMAT來轉換
        
        TO_DATE('11-APR-10'
        -------------------
        0011-04-10:00:00:00  --目前的date_format=YYYY-MM-DD:HH24:MI:SS.剛好可以implicit type conversion,但所得日期有相當大的誤差
        
        SQL> SELECT TO_DATE('11-APR-10','DD-MON-RR') FROM dual;
        
        TO_DATE('11-APR-10'
        -------------------
        2010-04-11:00:00:00
        
        SQL> SELECT TO_NUMBER('NT$100,999.00') FROM dual;
        SELECT TO_NUMBER('NT$100,999.00') FROM dual
                         *
         ERROR 在行 1:
        ORA-01722: 無效的數字
        
        
        SQL> SELECT TO_NUMBER('NT$100,999.00','L999,999.99') FROM dual;
        
        TO_NUMBER('NT$100,999.00','L999,999.99')
        ----------------------------------------
                                          100999
        
        SQL> SELECT TO_NUMBER('$100,999.00') FROM dual;
        SELECT TO_NUMBER('$100,999.00') FROM dual
                         *
         ERROR 在行 1:
        ORA-01722: 無效的數字
        
        
        SQL> SELECT TO_NUMBER('$100,999.00','$999,999.99') FROM dual;
        
        TO_NUMBER('$100,999.00','$999,999.99')
        --------------------------------------
                                        100999
        								
        SQL> SELECT TO_NUMBER('$100,999.00','$999G999D99') FROM dual;
        
        TO_NUMBER('$100,999.00','$999G999D99')
        --------------------------------------
                                        100999
        		 
		   
4. Nesting Functions
   -- Single-row functions can be nested to any level.
   -- Nested functions are evaluated from the deepest level to the least deep 
      level.
   F3( F2( F1( col, arg1 ), arg2 ) ,arg3 )
    ↑ ↑  ↑                ↑      ↑     ↑
    │ │  └─┤Step1=Result1├┘      │     │
    │ └────┤Step2=Result2├───────┘     │
    └──────┤Step3=Result3├─────────────┘

   Examples:
      SELECT last_name,
             UPPER( CONCAT( SUBSTR( LAST_NAME, 1, 8 ), '_US' ))
      FROM employees
      WHERE department_id = 60;
      -- The inner function retrieves the first eight characters of the last name.
         Result1 = SUBSTR( LAST_NAME, 1, 8 )
      -- The outer function concatenates the result with _US.
         Result2 = CONCAT( Result1, '_US' )
      -- The outermost function converts the results to uppercase.

   Examples:
      Display the date of the next Friday that is six months from the hire date.
      The resulting date should apper as Friday, August 13th, 1999. Order the
      results by hire date.
      SELECT TO_CHAR( NEXT_DAY( ADD_MONTHS( hire_date, 6 ), 'FRIDAY' ),
             'fmDay, Month ddth, YYYY')
             "Next 6 Month Review"
      FROM employees
      ORDER BY hire_date;

   Examples:
      Display the salaries of employees divided by 7 and rounded to two decimals.
      The result is then formatted to display the salary in Danish notation.
      SELECT TO_CHAR( ROUND( ( salary/7 ), 2), '99G999D99',
             'NLS_NUMERIC_CHARACTERS = '',.'' ' )
             "Formatted Salary"
      FROM employees;

5. General Functions

   General Functions
   ══════════════════════════════════════════════════════════════════════════
   Function    Description                                 
   ──────────────────────────────────────────────────────────────────────────
   NVL         NVL( expr1, expr2 )
               Converts a nll value to an actual value
   NVL2        NVL2( expr1, expr2, expr3 )
               If expr1 is not null, NVL2 returns expr2. If expr1 is null,
               NVL2 returns expr3. The argument expr1 can have any date type.
   NULLIF      NULLIF( expr1, expr2 )
               Compares two expressions and returns null if they are equal;
               returns the first expression if they are not equal.
   COALESCE    COALESCE( expr1, expr2, ..., exprn )
               Returns the first non-null expression in the expression list.
   ══════════════════════════════════════════════════════════════════════════

   5.1. NVL Function
        Syntax
        NVL( expr1, expr2 )
        -- expr1 is the source value or expression that may contain a null.
        -- expr2 is the target value for converting the null and this value is
           always the same as the data type of expr1.
        Examples:
           SELECT last_name, salary, NVL( commission_pct, 0 ),
                  ( salary * 12 ) + ( salary * 12 * NVL( commission_pct, 0 ) ) AN_SAL
           FROM employees;

           SELECT last_name, salary, commission_pct,
                  ( salary * 12 ) + ( salary * 12 * commission_pct ) AN_SAL
           FROM employees;

   5.2. NVL2 Function
        Syntax
        NVL2( expr1, expr2, expr3 )
        -- expr1 is the source value or expression that may contain a null
        -- expr2 is the value that is returned if expr1 is not null
        -- expr3 is the value that is returned if expr1 is null
        Examples:
           SELECT last_name, salary, commission_pct,
                  NVL2( commission_pct, 'SAL+COMM', 'SAL' ) income
           FROM employees
           WHERE department_id IN (50, 80);

   5.3. NULLIF Function
        Syntax
        NULLIF( expr1, expr2 )
        -- NULL compares expr1 and expr2. If they are equal, the function 
           returns null. If they are not, the function return expr1.
        -- However, you cannot specify the literal NULL for expr1.
        -- The NULLIF function is logically equivalent to the following CASE 
           expression.
           CASE WHEN expr1 = expr2 THEN NULL ELSE expr1 END
        Examples:
           SELECT first_name, LENGTH( first_name ) "expr1",
                  last_name, LENGTH( last_name ) "expr2",
                  NULLIF( LENGTH( first_name ), LENGTH( last_name ) ) result
           FROM employees;

    5.4. COALESCE Function
         Syntax
         COALESCE( expr1, expr2, ..., exprn )
         -- expr1 returns this expression if it is not null
         -- expr2 returns this expression if the first expression is null and
                  this expression is not null
         -- expr3 returns this expression if the preceding expressions are null
         -- The advantage of the COALESCE function over the NVL function is that
            the COALESCE function can take multiple alternate values.
         Examples:
            SELECT last_name, employee_id,
                   COALESCE( TO_CHAR( commission_pct ), TO_CHAR( manager_id ),
                   'NO commission and no manager' )
            FROM employees;

         Examples:
            For the employees who do not get any commission, your organization 
            wants to give a salary increment of $2,000 and for employees who get
            commission, the query should compute the new salary that is equal to
            the existing salary added to the commission amount.
            SELECT last_name, salary, commission_pct,
                   COALESCE( ( salary + ( commission_pct * salary ) ), salary + 
                             2000, salary ) "New Salary"
            FROM employees;

6. Conditional expressions
   -- Provide the use of the IF-THEN-ELSE logic within a SQL statement.
   -- Use two methods:
      - CASE expression
      - DECODE expression

   6.1. Using the CASE Expression  
        Syntax
        CASE expr WHEN comparison_expr1 THEN return_expr1
                 [WHEN comparison_expr2 THEN return_expr2
                  WHEN comparison_exprn THEN return_exprn
                  ELSE else_expr]
        END

        The expression expr and comparison_expr must be of the same date type, 
        which can be CHAR, VARCHAR2, NCHAR, or NVARCHAR2. All of the return 
        values ( return_expr ) must be of the same data type.
        Examples:
           SELECT last_name, job_id, salary,
                  CASE job_id WHEN 'IT_PROG'  THEN 1.10 * salary
                              WHEN 'ST_CLERK' THEN 1.15 * salary
                              WHEN 'SA_ERP'   THEN 1.20 * salary
                  ELSE    salary
                  END "REVISED_SALARY"
           FROM employees;

        Examples:
           SELECT last_name, salary,
                  ( CASE WHEN salary < 5000  THEN 'Low'
                         WHEN salary < 10000 THEN 'Medium'
                         WHEN salary < 20000 THEN 'Good'
                         ELSE 'Excellent'
                    END )
           ROMR employees;

   6.2. DECODE Function
        Syntax
        DECODE( col|expression, search1, result1
                                [, search2, result2, ...,]
                                [, default] )

        The DECODE function decodes expression after comparing it to each
        search value. If expression is the same as search, result is returned.

        If the default value is omitted, a null value is returned where a search
        value does not match any of the result values.
        Examples:
           SELECT last_name, job_id, salary,
                  DECODE( job_id, 'IT_PROG',  1.10 * salary,
                                  'ST_CLERK', 1.15 * salary,
                                  'SA_REP',   1.20 * salary,
                          salary )
                  REVISED_SALARY
           FROM employees;

        Examples:
           Display the applicable tax rate for each employee in department 80:
           SELECT last_name, salary,
                  DECODE( TRUNC( salary/2000, 0 ),
                               0, 0.00,
                               1, 0.09,
                               2, 0.20,
                               3, 0.30,
                               4, 0.40,
                               5, 0.42,
                               6, 0.44,
                                  0.45 ) TAX_RATE
            FROM employees
            WHERE departmaent_id = 80;
