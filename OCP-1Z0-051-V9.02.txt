1. View the Exhibit and examine the structure of the SALES, CUSTOMERS, PRODUCTS,
   and TIMES tables.
   The PROD_ID column is the foreign key in the SALES table, which references 
   the PRODUCTS table. Similarly, the CUST_ID and TIME_ID columns are also 
   foreign keys in the SALES table referencing the CUSTOMERS and TIMES tables, 
   respectively.
   Evaluate the following CREATE TABLE command:
   CREATE TABLE new_sales(prod_id, cust_id, order_date DEFAULT SYSDATE)
   AS
   SELECT prod_id, cust_id, time_id
   FROM sales;
   Which statement is true regarding the above command?    
                                             ┌────────────────────────────────────────────────────────┐
                                             │                                                        │ 
                                             │   ┌──────────────────────────────────────────┐         │   ┌────────────────────────────────────────────┐
                                             │   │Table PROMOTIONS                          │         │   │Table TIMES                                 │
                                             │   ├────────────────────┬────────┬────────────┤         │   ├──────────────────────┬────────┬────────────┤
                                             │   │Name                │Null?   │Type        │         │   │Name                  │Null?   │Type        │
                                             │   ├────────────────────┼────────┼────────────┤         │   ├──────────────────────┼────────┼────────────┤
                                             │ ┌─┤PROMO_ID            │NOT NULL│NUMBER(6)   ├───────┐ ├───┤TIME_ID               │NOT NULL│DATE        │
                                             │ │ │PROMO_NAME          │NOT NULL│VARCHAR2(30)│       │ │   │DAY_NAME              │NOT NULL│VARCHAR2(9) │
                                             │ │ │PROMO_SUBCATEGORY   │NOT NULL│VARCHAR2(30)│       │ │   │DAY_NUMBER_IN_MONTH   │NOT NULL│NUMBER(2)   │
                                             │ │ │PROMO_SUBCATEGORY_ID│NOT NULL│NUMBER      │       │ │   │CALENDAR_WEEK_NUMBER  │NOT NULL│NUMBER(2)   │
                                             │ │ │PROMO_CATEGORY      │NOT NULL│VARCHAR2(30)│       │ │   │CALENDAR_MONTH_NUMBER │NOT NULL│NUMBER(2)   │
                                             │ │ │PROMO_CATEGORY_ID   │NOT NULL│NUMBER      │       │ │   │CALENDAR_MONTH_NAME   │NOT NULL│VARCHAR2(9) │
       ┌────────────────────────────────┐    │ │ │PROMO_COST          │NOT NULL│NUMBER(10,2)│       │ │   │CALENDAR_YEAR         │NOT NULL│NUMBER(4)   │
       │Table COSTS                     │    │ │ │PROMO_BEGIN_DATE    │NOT NULL│DATE        │       │ │   └──────────────────────┴────────┴────────────┘
       ├──────────┬────────┬────────────┤    │ │ │PROMO_END_DATE      │NOT NULL│DATE        │       │ │
       │Name      │Null?   │Type        │    │ │ └────────────────────┴────────┴────────────┘       │ │
       ├──────────┼────────┼────────────┤    │ │                                                    │ │
   ┌─＜│PROD_ID   │NOT NULL│NUMBER      │    │ │                                                    │ │
   │   │TIME_ID   │NOT NULL│DATE        │＞──┘ │                                                    │ │
   │   │PROMO_ID  │NOT NULL│NUMBER      │＞────┘                                                    │ │
   │   │CHANNEL_ID│NOT NULL│NUMBER      │                                                           │ │
   │   │UNIT_COST │NOT NULL│NUMBER(10,2)│                   ┌───────────────────────────────────┐   │ │
   │   │UNIT_PRICE│NOT NULL│NUMBER(10,2)│                   │Table SALES                        │   │ │
   │   └──────────┴────────┴────────────┘                   ├─────────────┬────────┬────────────┤   │ │
   │                                                        │Name         │Null?   │Type        │   │ │
   │                                                        ├─────────────┼────────┼────────────┤   │ │
   │                                                  ┌───＜│PROD_ID      │NOT NULL│NUMBER      │   │ │
   │   ┌────────────────────────────────────────────┐ │ ┌─＜│CUST_ID      │NOT NULL│NUMBER      │   │ │
   │   │Table PRODUCTS                              │ │ │   │TIME_ID      │NOT NULL│DATE        │＞─┼─┘
   │   ├────────────────────┬────────┬──────────────┤ │ │   │CHANNEL_ID   │NOT NULL│NUMBER      │＞─┼─┐
   │   │Name                │Null?   │Type          │ │ │   │PROMO_ID     │NOT NULL│NUMBER      │＞─┘ │
   │   ├────────────────────┼────────┼──────────────┤ │ │   │QUANTITY_SOLD│NOT NULL│NUMBER(10,2)│     │
   └───┤PROD_ID             │NOT NULL│NUMBER(6)     ├─┘ │   └─────────────┴────────┴────────────┘     │
       │PROD_NAME           │NOT NULL│VARCHAR2(50)  │   │                                             │
       │PROD_DESC           │NOT NULL│VARCHAR2(4000)│   │                                             │
       │PROD_CATEGORY       │NOT NULL│VARCHAR2(50)  │   │                                             │
       │PROD_CATEGORY_ID    │NOT NULL│NUMBER        │   │   ┌───────────────────────────────────────┐ │
       │PROD_UNIT_OF_MEASURE│        │VARCHAR2(20)  │   │   │Table CHANNELS                         │ │
       │SUPPLIER_ID         │NOT NULL│NUMBER(6)     │   │   ├─────────────────┬────────┬────────────┤ │
       │PROD_STATUS         │NOT NULL│VARCHAR2(20)  │   │   │Name             │Null?   │Type        │ │
       │PROD_LIST_PRICE     │NOT NULL│NUMBER(8,2)   │   │   ├─────────────────┼────────┼────────────┤ │
       │PROD_MIN_PRICE      │NOT NULL│NUMBER(8,2)   │	│   │CHANNELS_ID      │NOT NULL│NUMBER      ├─┘
       └────────────────────┴────────┴──────────────┘   │   │CHANNELS_DESC    │NOT NULL│VARCHAR2(20)│
                                                        │   │CHANNELS_CLASS   │NOT NULL│VARCHAR2(20)│
                                                        │   │CHANNELS_CLASS_ID│NOT NULL│NUMBER      │
                                                        │   │CHANNELS_TOTAL   │NOT NULL│VARCHAR2(13)│
                                                        │   │CHANNELS_TOTAL_ID│NOT NULL│NUMBER      │
                                                        │   └─────────────────┴────────┴────────────┘
                                                        │  
                                                        │  
                                                        │  
														│   ┌──────────────────────────────────────────┐     ┌────────────────────────────────────┐
														│   │Table CUSTOMERS                           │     │Table COUNTRIES                     │
                                                        │   ├────────────────────┬────────┬────────────┤     ├──────────────┬────────┬────────────┤
                                                        │   │Name                │Null?   │Type        │     │Name          │Null?   │Type        │
                                                        │   ├────────────────────┼────────┼────────────┤     ├──────────────┼────────┼────────────┤
                                                        └───┤CUST_ID             │NOT NULL│NUMBER      │   ┌─┤COUNTRY_ID    │NOT NULL│NUMBER      │
                                                            │CUST_FIRST_NAME     │NOT NULL│VARCHAR2(20)│   │ │COUNTRY_NAME  │NOT NULL│VARCHAR2(40)│
                                                            │CUST_LAST_NAME      │NOT NULL│VARCHAR2(40)│   │ │COUNTRY_REGION│NOT NULL│VARCHAR2(20)│
                                                            │CUST_GENDER         │NOT NULL│CHAR(1)     │   │ │COUNTRY_TOTAL │NOT NULL│VARCHAR2(11)│
                                                            │CUST_YEAR_OF_BIRTH  │NOT NULL│NUMBER(4)   │   │ └──────────────┴────────┴────────────┘
                                                            │CUST_MARITIAL_STATUS│        │VARCHAR2(20)│   │       
															│CUST_STREET_ADDRESS │NOT NULL│VARCHAR2(40)│   │       
															│CUST_POSTAL_CODE    │NOT NULL│VARCHAR2(10)│   │       
															│CUST_CITY           │NOT NULL│VARCHAR2(30)│   │
															│CUST_STATE_PROVINCE │NOT NULL│VARCHAR2(40)│   │
															│COUNTRY_ID          │NOT NULL│NUMBER      │＞─┘
															│CUST_INCOME_LEVEL   │        │VARCHAR2(30)│  
															│CUST_CREDIT_LIMIT   │        │NUMBER      │
															│CUST_EMAIL          │        │VARCHAR2(30)│
															└────────────────────┴────────┴────────────┘
                                                                      
   A. The NEW_SALES table would not get created because the DEFAULT value cannot 
      be specified in the column definition.
   B. The NEW_SALES table would get created and all the NOT NULL constraints 
      defined on the specified columns would be passed to the new table. 
   C. The NEW_SALES table would not get created because the column names in the 
      CREATE TABLE command and the SELECT clause do not match. 
   D. The NEW_SALES table would get created and all the FOREIGN KEY constraints 
      defined on the specified columns would be passed to the new table.

   Answer: B  
   分析
   ═════════════════════════════════════════════════════════════════════════════
   答案
   選項   答案說明
   ─────────────────────────────────────────────────────────────────────────────
    A     NEW_SALES table 是可以被create出來的
	      The column definition can contain only the column name and default 
		  value.
		  
          驗証 -- 
          > CREATE TABLE new_sales(prod_id, cust_id, order_date DEFAULT SYSDATE) 
		  3 AS
          2 SELECT prod_id, cust_id, time_id FROM sales;
          Table created.
   ─────────────────────────────────────────────────────────────────────────────
    B     僅 NOT NULL constraint 會被繼承至新的Table中
          The column data type definitions and the NOT NULL constraint are 
		  passed to the new table. 
		  Note that only the explicit NOT NULL constraint will be inherited. The 
		  PRIMARY KEY column will not pass theNOT NULL feature to the new 
		  column. Any other constraint rules are not passed to the new table. 
		  However, you can add constraints in the column definition.
		  
		  驗証一 --
		  > desc SALES
		   Name                       Null?    Type
          -------------------------- -------- ----------------------------------
           PROD_ID                    NOT NULL NUMBER
           CUST_ID                    NOT NULL NUMBER
           TIME_ID                    NOT NULL DATE
           CHANNEL_ID                 NOT NULL NUMBER
           PROMO_ID                   NOT NULL NUMBER
           QUANTITY_SOLD              NOT NULL NUMBER(10,2)
           AMOUNT_SOLD                NOT NULL NUMBER(10,2)
		  
		  > desc new_sales
		   Name                       Null?    Type
          -------------------------- -------- ----------------------------------
           PROD_ID                    NOT NULL NUMBER
           CUST_ID                    NOT NULL NUMBER
           ORDER_DATE                 NOT NULL DATE

          驗証二 --
		  > select a.owner,a.TABLE_NAME,b.COLUMN_NAME,a.CONSTRAINT_NAME,
		           a.CONSTRAINT_TYPE,a.SEARCH_CONDITION
          2  from USER_CONSTRAINTS a,USER_CONS_COLUMNS b
          3  where a.CONSTRAINT_NAME=b.CONSTRAINT_NAME and A.table_name='SALES';
          OWNER  TABLE_NAME COLUMN_NAME     CONSTRAINT_NAME      CONSTRAINT SEARCH_CONDITION
          ------ ---------- --------------- -------------------- ---------- ------------------------------
          XX     SALES      CUST_ID         SALES_CUSTOMER_FK    R          
          XX     SALES      PROD_ID         SALES_PRODUCT_FK     R
          XX     SALES      TIME_ID         SALES_TIME_FK        R
          XX     SALES      CHANNEL_ID      SALES_CHANNEL_FK     R
          XX     SALES      PROD_ID         SYS_C0011009         C          "PROD_ID" IS NOT NULL
          XX     SALES      CUST_ID         SYS_C0011010         C          "CUST_ID" IS NOT NULL
          XX     SALES      TIME_ID         SYS_C0011011         C          "TIME_ID" IS NOT NULL
          XX     SALES      CHANNEL_ID      SYS_C0011012         C          "CHANNEL_ID" IS NOT NULL
          XX     SALES      PROMO_ID        SYS_C0011013         C          "PROMO_ID" IS NOT NULL
          XX     SALES      QUANTITY_SOLD   SYS_C0011014         C          "QUANTITY_SOLD" IS NOT NULL
          XX     SALES      AMOUNT_SOLD     SYS_C0011015         C          "AMOUNT_SOLD" IS NOT NULL
          XX     SALES      PROMO_ID        SALES_PROMO_FK       R
 
         12 rows selected.		  
		 
		 > select a.owner,a.TABLE_NAME,b.COLUMN_NAME,a.CONSTRAINT_NAME,
		          a.CONSTRAINT_TYPE,a.SEARCH_CONDITION
         2  from USER_CONSTRAINTS a,USER_CONS_COLUMNS b
         3*  where a.CONSTRAINT_NAME=b.CONSTRAINT_NAME and A.table_name='NEW_SALES'
         OWNER  TABLE_NAME COLUMN_NAME     CONSTRAINT_NAME   CONSTRAINT SEARCH_CONDITION
         ------ ---------- --------------- ----------------- ---------- ------------------------------
         XX     NEW_SALES  PROD_ID         SYS_C0011428      C          "PROD_ID" IS NOT NULL
         XX     NEW_SALES  CUST_ID         SYS_C0011429      C          "CUST_ID" IS NOT NULL
         XX     NEW_SALES  ORDER_DATE      SYS_C0011430      C          "ORDER_DATE" IS NOT NULL
   ─────────────────────────────────────────────────────────────────────────────
	C	 NEW_SALES table 是可以被create出來的
	     If column specifications are given, the number of columns must equal 
		 the number of columns in the subquery SELECT list.
   ─────────────────────────────────────────────────────────────────────────────
    D    如答案B的說明, 僅 NOT NULL constraint 會被繼承至新的Table中, 其他的
         constraint, 如, SALES_PRODUCT_FK，SALES_CUSTOMER_FK，SALES_TIME_FK 這三
         個Foriegn key是不會被繼承至新的Table中。
   ═════════════════════════════════════════════════════════════════════════════
		 
2. View the Exhibit to examine the description for the SALES table.
   ┌───────────────────────────────────┐
   │Table SALES                        │
   ├─────────────┬────────┬────────────┤
   │Name         │Null?   │Type        │
   ├─────────────┼────────┼────────────┤
   │PROD_ID      │NOT NULL│NUMBER      │
   │CUST_ID      │NOT NULL│NUMBER      │
   │TIME_ID      │NOT NULL│DATE        │
   │CHANNEL_ID   │NOT NULL│NUMBER      │
   │PROMO_ID     │NOT NULL│NUMBER      │
   │QUANTITY_SOLD│NOT NULL│NUMBER(10,2)│
   └─────────────┴────────┴────────────┘
   Which views can have all DML operations performed on it? (Choose all that apply.) 
   A. CREATE VIEW v3
      AS SELECT * FROM SALES   
      WHERE cust_id = 2034   
      WITH CHECK OPTION;
   B. CREATE VIEW v1
      AS SELECT * FROM SALES   
      WHERE time_id <= SYSDATE - 2*365   
      WITH CHECK OPTION;
   C. CREATE VIEW v2
      AS SELECT prod_id, cust_id, time_id FROM SALES   
      WHERE time_id <= SYSDATE - 2*365   
      WITH CHECK OPTION; 
   D. CREATE VIEW v4
      AS SELECT prod_id, cust_id, SUM(quantity_sold) FROM SALES   
      WHERE time_id <= SYSDATE - 2*365   
      GROUP BY prod_id, cust_id   
      WITH CHECK OPTION;
	  
   Answer: AB
   分析
   ═════════════════════════════════════════════════════════════════════════════
   答案
   選項   答案說明
   ─────────────────────────────────────────────────────────────────────────────
   C      NOT NULL columns in the base tables that are not selected by the view.
   ─────────────────────────────────────────────────────────────────────────────
   D      alias Specifies names for the expressions selected by the view’s query
          (The number of aliases must match the number of expressions selected 
		  by the view.)
          WITH CHECK OPTION Specifies that only those rows that are accessible 
          to the view can be inserted or updated.
          驗証 --
		  > create view v4
          2  as select prod_id,cust_id,sum(quantity_sold) from sales
          3  where time_id<=sysdate-2*365
          4  group by prod_id,cust_id
          5  with check option
          6  ;
          as select prod_id,cust_id,sum(quantity_sold) from sales
                                  *
          ERROR at line 2:
          ORA-00998: must name this expression with a column alias
   
          > create view v4
          2  as select prod_id,cust_id,sum(quantity_sold) sumqty from sales
          3   where time_id<=sysdate-2*365
          4  group by prod_id,cust_id
          5  with check option
          6  ;
   ═════════════════════════════════════════════════════════════════════════════
   
   Rules for Performing DML Operations on a View --
   ═════════════════════════════════════════════════════════════════════════════
   Cannot remove data               Cannot modify data                Cannot remove data
   in view if it contains           in view if it contains            in view if it contains
   ─────────────────────────────────────────────────────────────────────────────
   Group functions                  Group functions                   Group functions
   A GROUP BY clause                A GROUP BY clause                 A GROUP BY clause
   The DISTINCY keyword             The DISTINCY keyword              The DISTINCY keyword
   The pseudocolumn ROWNUM keyword  The pseudocolumn ROWNUM keyword   The pseudocolumn ROWNUM keyword
                                    Columns defined by expressions    Columns defined by expressions
									                                  NOT NULL columns in the base table that are not selected by the view
   ─────────────────────────────────────────────────────────────────────────────
   
3. You need to extract details of those products in the SALES table where the 
   PROD_ID column contains the string '_D123'.
   Which WHERE clause could  be used in the SELECT statement to get the required output?
   A. WHERE prod_id LIKE '%_D123%' ESCAPE '_'
   B. WHERE prod_id LIKE '%\_D123%' ESCAPE '\'
   C. WHERE prod_id LIKE '%_D123%' ESCAPE '%_'
   D. WHERE prod_id LIKE '%\_D123%' ESCAPE '\_'
   
   Answer: B
   分析   
   The two wildcard characters ( % and _ ) can be used in any combination with 
   literal characters for pattern matching.
   
   ESCAPE Identifier --
   When you need to have exact match for the actual % and _ characters, use the
   ESCAPE identifier.
   

4. Which two statements are true regarding single row functions? (Choose two.)
   A. They accept only a single argument.
   B. They can be nested only to two levels.
   C. Arguments can only be column values or constants.
   D. They always return a single result row for every row of a queried table.
   E. They can return a data type value different from the one that is referenced.
   
   Answer: DE

   分析
   ═════════════════════════════════════════════════════════════════════════════
   答案
   選項   答案說明
   ─────────────────────────────────────────────────────────────────────────────
   A      可以接受一個或多個參數
          They accept one or more arguments and return one value for each row 
		  that is returned by the query.
   ─────────────────────────────────────────────────────────────────────────────
   B	  Single-row functions 可以無限 Nested.
          Multip-row functions 只能2層 Nested.
   ─────────────────────────────────────────────────────────────────────────────
   C      An argument can be one of the following:
	      User-supplied constant
	      Variable value
	      Column name
	      Expression
   ─────────────────────────────────────────────────────────────────────────────
   D      Returning one result per row
   ─────────────────────────────────────────────────────────────────────────────
   E      Possibly returning a data value of a different type than the one that 
          is referenced   
   ═════════════════════════════════════════════════════════════════════════════
   
   Single-row functions --
   1. Single-row functions are used to manipulate data items. They accept one or
      more arguments and return one value for each row that is returned by the 
	  query. An argument can be one of the following:
	  User-supplied constant
	  Variable value
	  Column name
	  Expression
  
   2. Features of single-row functions include:
      Acting on each row that is returned in the query
      Returning one result per row
      Possibly returning a data value of a different type than the one that is referenced
      Possibly expecting one or more arguments
      Can be used in SELECT, WHERE, and ORDER BY clauses; can be nested.	  
   
5. Which SQL statements would display the value 1890.55 as $1,890.55? (Choose three .)
   A. SELECT TO_CHAR(1890.55,'$0G000D00')
      FROM DUAL;
   B. SELECT TO_CHAR(1890.55,'$9,999V99')
      FROM DUAL; 
   C. SELECT TO_CHAR(1890.55,'$99,999D99')                         
      FROM DUAL;
   D. SELECT TO_CHAR(1890.55,'$99G999D00')
      FROM DUAL;
   E. SELECT TO_CHAR(1890.55,'$99G999D99')
      FROM DUAL;
   
   Answer: ADE

   分析
   ═════════════════════════════════════════════════════════════════════════════
   答案
   選項   答案說明
   ─────────────────────────────────────────────────────────────────────────────
   A      > SELECT TO_CHAR(1890.55,'$0G000D00') FROM DUAL;  
          
		  TO_CHAR(18
          ----------
          $1,890.55
   ─────────────────────────────────────────────────────────────────────────────
   B      > SELECT TO_CHAR(1890.55,'$9,999V99') FROM DUAL;
          
		  TO_CHAR(1
          ---------
          $1,89055
   ─────────────────────────────────────────────────────────────────────────────
   C      > SELECT TO_CHAR(1890.55,'$99,999D99') FROM DUAL;
            SELECT TO_CHAR(1890.55,'$99,999D99') FROM DUAL
                                   *
            ERROR at line 1:
            ORA-01481: invalid number format model 
   ─────────────────────────────────────────────────────────────────────────────
   D      >  SELECT TO_CHAR(1890.55,'$99G999D00') FROM DUAL;
   
          TO_CHAR(189
          -----------
          $1,890.55
   ─────────────────────────────────────────────────────────────────────────────
   E      > SELECT TO_CHAR(1890.55,'$99G999D99') FROM DUAL;
   
          TO_CHAR(189
          -----------
          $1,890.55
   ═════════════════════════════════════════════════════════════════════════════
   
   答案解析：
   G表示分组分隔符group
   D表示小数点decimal point
   V表示移动N位（小数点），乘以10的n次方后面跟几位就是几次方
   如：
   to_char(12,'99V999') ' 12000'
   to_char(12.4,'99V999') ' 12400'
   to_char(12.45, '99V9') ' 125'
   0表示补齐位数。
   实验验证
   
   
6. Examine the structure of the SHIPMENTS table:
   name           Null       Type
   PO_ID          NOT NULL    NUMBER(3)
   PO_DATE        NOT NULL    DATE
   SHIPMENT_DATE  NOT NULL    DATE
   SHIPMENT_MODE              VARCHAR2(30)
   SHIPMENT_COST              NUMBER(8,2)
   You want to generate a report that displays the PO_ID and the penalty amount to be paid if the
   SHIPMENT_DATE is later than one month from the PO_DATE. The penalty is $20 per day.
   Evaluate the following two queries:
   SQL> SELECT po_id, CASE
   WHEN MONTHS_BETWEEN (shipment_date,po_date)>1 THEN
   TO_CHAR((shipment_date - po_date) * 20) ELSE 'No Penalty' END PENALTY
   FROM shipments;
   SQL>SELECT po_id, DECODE
   (MONTHS_BETWEEN (po_date,shipment_date)>1,
   TO_CHAR((shipment_date - po_date) * 20), 'No Penalty') PENALTY   
   FROM shipments;
   Which statement is true regarding the above commands?
   A. Both execute successfully and give correct results.
   B. Only the first query executes successfully but gives a wrong result.
   C. Only the first query executes successfully and gives the  correct result.
   D. Only the second query executes successfully but gives a wrong result.
   E. Only the second query executes successfully and gives the correct result.
   
   
   Answer: C
   答案解析：
   参考：http://blog.csdn.net/rlhua/article/details/12868497
   http://blog.csdn.net/rlhua/article/details/12848395
   
   题意要求： 显示PO_ID和支付的罚款总金额，SHIPMENT_DATE与PO_DATE进行比较，SHIPMENT_DATE如果比PO_DATE晚一个月，则每天罚款$20。
   
   MONTHS_BETWEEN(date1, date2): 返回date1和date2两个日期之间间隔几个月，结果可以为正或为负。如果date1晚于date2则结果为正;如果date1早于date2则结果为负;结果的非整数部分也代表月间隔的一部分。
    
   DECODE(expr,search1,result1[,search2,result2……,default])：比较expr与search，如果等于search1则返回result1，如果等于search2则返回result2，依次类推，如果都不等于，如果有default则返回default，否则返回NULL.
   ORACLE在比较之前，会自动把expr和每一个search隐式转换成第一个search（search1）的数据类型。自动把返回值转换成第一个result（result1）的数据类型。如果第一个result的数据类型为CHAR或者值是null，则Oracle转换返回值为VARCHAR2. 
   在DECODE函数中,NULL是相等的，如果expr为空，则Oracle将会返回第一个为NULL的search所对应的result。DECODE列表中的最大表达式个数为255个。
   
   第一个SQL的表达是正确，可以正确执行的。其实我觉得这道题的答案有点出入，MONTHS_BETWEEN返回的是月数，每天罚款$20，相乘起来，因为一个是天的单位，一个是月的单位，如果题中改成每月罚款20，则才是正确的。
    DECODE 的表达是错误的。
   sh@TEST0924> SELECT po_id, DECODE (MONTHS_BETWEEN (po_date,shipment_date)>1,
     2  TO_CHAR((shipment_date - po_date) * 20), 'No Penalty') PENALTY
     3  FROM shipments;
   SELECT po_id, DECODE (MONTHS_BETWEEN (po_date,shipment_date)>1,
                                                               *
   ERROR at line 1:
   ORA-00907: missing right parenthesis

7. Which two  statements are true regarding the USING and ON clauses in table joins? (Choose two.)
A. Both USING and ON clauses can be used for equijoins and nonequijoins. 
B. A maximum of one pair of columns can be joined between two tables using the ON clause. 
C. The  ON clause can be used to join tables on columns that have different names but compatible data
types.
D. The  WHERE clause can be used to apply additional conditions in SELECT statements containing the
ON or the  USING clause.
Answer: CD
答案解析：
参考：http://blog.csdn.net/rlhua/article/details/12877591
A, USING和ON子句可以用于等值连接和非等值连接,USING不能用于非等值连接，ON可以。
B, 使用ON子句最大只能使用两个列连接两个表.错误，可以连接多个列
C,ON子句用于连接表的列可以是不同的名字，但是数据类型要兼容，正确。ON子句还可以用于联接同一表内或者不同表中具有不同名称的列。
D,在包含ON或USING子句的SELECT命令中，WHERE子句可以做为附加的条件，正确。

8. View the Exhibit and examine the structure of the CUSTOMERS table.
Which two tasks would require subqueries or joins to be executed in a single statement? (Choose two.) 

A. listing of customers who do not have a credit limit and were born before 1980
B. finding the number of customers, in each city, whose marital status is 'married'
C. finding the average credit limit of male customers residing in 'Tokyo' or 'Sydney'
D. listing of those customers whose credit limit is the same as the credit limit of customers residing in the
city 'Tokyo'
E. finding the number of customers, in each city, whose credit limit is more than the average credit limit of
all the customers
Answer: DE
答案解析：
参考：http://blog.csdn.net/rlhua/article/details/12879585
ABC不用子查询就可以查询出，题意选择两个，排除ABC,选择DE

A. 列出没有信贷限额并且1980年以前出生的客户。
SELECT 客户 from 表名 where 信贷限额 is null and 出生日期>1980;

B. 查找每个城市的已婚客户的数量。
SELECT 城市名，COUNT(*) FROM 表名 where 客户婚否=‘结婚’ group by 城市名;

C. 查找属于'Tokyo'或者 'Sydney'两个城市的男性客户的平均信贷限额。
SELECT 城市名， AVG(信贷限额) from 表名 where 性别=‘男’ and 城市 in（'Tokyo'， 'Sydney'） group by 城市名

D 列出与'Tokyo'城市的客户的信贷限额相等的客户
E. 查找每个城市的客户数量，这些客户的信贷限额大于所有客户的平均信贷限额。

9. Which statement is true regarding the INTERSECT operator?
A. It ignores NULL values.
B. Reversing the order of the intersected tables alters the result.
C. The names of columns in all SELECT statements must be identical.
D. The number of columns and data   types must be identical for all SELECT statements in the query.
Answer: D
答案解析：
参考：http://blog.csdn.net/rlhua/article/details/12883007
A. 它忽略空值，错误，不会忽略空值
B. 交换交集表的前后顺序可以改变交集结果，错误，不会改变结果
C. 所有SELECT查询语句中的列的名字必须相同。错误，列名可以不必相同
D. 对于所有SELECT查询语句，列的数量和数据类型必须相同。

使用INTERSECT运算符可以返回多个查询的所有共同行。
准则
• 在查询中使用的所有SELECT语句中，由查询中的SELECT语句选定的列数和列的数据类型必须相同。不过，列名不必相同。
• 使相交的表按反方向排序不会更改结果。
• INTERSECT不会忽略NULL值。

10. View the Exhibit; e xamine the structure of the PROMOTIONS table.

Each promotion has a duration of at least seven days .
Your manager has asked you to generate a report,  which provides the weekly cost for each promotion
done to l date.
Which query would achieve the required result? 
A. SELECT promo_name, promo_cost/promo_end_date-promo_begin_date/7
FROM promotions;
B. SELECT promo_name,(promo_cost/promo_end_date-promo_begin_date)/7
FROM promotions;
C. SELECT promo_name, promo_cost/(promo_end_date-promo_begin_date/7)
FROM promotions;
D. SELECT promo_name, promo_cost/((promo_end_date-promo_begin_date)/7)
FROM promotions;
Answer: D
答案解析：
提要要求:报表提供促销期间每周的成本
D,正确，符合题意。
AB C语法错误
sh@TEST0924> SELECT promo_name, promo_cost/promo_end_date-promo_begin_date/7 FROM promotions;
SELECT promo_name, promo_cost/promo_end_date-promo_begin_date/7 FROM promotions
                              *
ERROR at line 1:
ORA-00932: inconsistent datatypes: expected NUMBER got DATE

sh@TEST0924> SELECT promo_name,(promo_cost/promo_end_date-promo_begin_date)/7 FROM promotions;
SELECT promo_name,(promo_cost/promo_end_date-promo_begin_date)/7 FROM promotions
                              *
ERROR at line 1:
ORA-00932: inconsistent datatypes: expected NUMBER got DATE

sh@TEST0924> SELECT promo_name, promo_cost/(promo_end_date-promo_begin_date/7) FROM promotions;
SELECT promo_name, promo_cost/(promo_end_date-promo_begin_date/7) FROM promotions
                                              *
ERROR at line 1:
ORA-00932: inconsistent datatypes: expected NUMBER got DATE

11. View the Exhibit and examine the structure of the PRODUCTS table.
All products have a list price. 
You issue the following command to display the total price of each product after a discount of 25% and a
tax of 15% are  applied on it. Freight charges of $100 have to be applied to all the products.
SQL>SELECT prod_name, prod_list_price -(prod_list_price*(25/100))                 
+(prod_list_price -(prod_list_price*(25/100))*(15/100))+100                                 
AS "TOTAL PRICE" 
FROM products; 
What would be the outcome if all the parenthese s are removed from the above statement?
 
A. It produces a syntax error.
B. The result remains unchanged. 
C. The total price value would be lower than the correct value. 
D. The total price value would be higher than the correct value.
 
[html] view plaincopyprint?
<span style="font-size:12px;">sh@TESTDB> SELECT prod_name, prod_list_price -(prod_list_price*(25/100))                    
  2  +(prod_list_price -(prod_list_price*(25/100))*(15/100))+100                                    
  3  AS "TOTAL PRICE"   
  4  FROM products where rownum<6   
  5  order by "TOTAL PRICE";  
  
PROD_NAME                                          TOTAL PRICE  
-------------------------------------------------- -----------  
Y Box                                               613.732875  
5MP Telephoto Digital Camera                        1641.23288  
17" LCD w/built-in HDTV Tuner                       1812.48288  
Envoy 256MB - 40GB                                  1812.48288  
Mini DV Camcorder with 3.5" Swivel LCD              1983.73288</span>  

12. You need to produce a report where each customer's credit limit has been incremented by $1000. In
the output, t he customer's last name should have the heading Name and the   incremented credit limit
should be labeled New Credit Limit. The column headings should have only the first letter of each word in
uppercase . 
Which statement would accomplish this requirement? 
A.
SELECT cust_last_name Name, cust_credit_limit + 1000      
"New Credit Limit" 
FROM customers;
[sql] view plaincopyprint?
sh@TESTDB> SELECT cust_last_name Name, cust_credit_limit + 1000        
  2  "New Credit Limit"   
  3  FROM customers WHERE ROWNUM<6;   
  
NAME                                               New Credit Limit  
-------------------------------------------------- ----------------  
Ruddy                                                          2500  
Ruddy                                                          8000  
Ruddy                                                         12000  
Ruddy                                                          2500  
Ruddy                                                         10000  

 

B.
SELECT cust_last_name AS Name, cust_credit_limit + 1000       
AS New Credit Limit 
FROM customers;
 
[sql] view plaincopyprint?
sh@TESTDB> SELECT cust_last_name AS Name, cust_credit_limit + 1000         
  2  AS New Credit Limit   
  3  FROM customers WHERE ROWNUM<6;   
AS New Credit Limit  
       *  
ERROR at line 2:  
ORA-00923: FROM keyword not found where expected  

 

C.
SELECT cust_last_name AS "Name", cust_credit_limit + 1000       
AS "New Credit Limit" 
FROM customers;
 
[sql] view plaincopyprint?
<a target="_blank" href="mailto:sh@TESTDB">sh@TESTDB</a>> SELECT cust_last_name AS "Name", cust_credit_limit + 1000         
  2  AS "New Credit Limit"   
  3  FROM customers WHERE ROWNUM<6;   
  
Name                                               New Credit Limit  
-------------------------------------------------- ----------------  
Ruddy                                                          2500  
Ruddy                                                          8000  
Ruddy                                                         12000  
Ruddy                                                          2500  
Ruddy                                                         10000  

 

D.
SELECT INITCAP(cust_last_name) "Name", cust_credit_limit + 1000       
INITCAP("NEW CREDIT LIMIT") 
FROM customers;
 
[sql] view plaincopyprint?
sh@TESTDB> SELECT INITCAP(cust_last_name) "Name", cust_credit_limit + 1000         
  2  INITCAP("NEW CREDIT LIMIT")   
  3  FROM customers WHERE ROWNUM<6;  
INITCAP("NEW CREDIT LIMIT")  
       *  
ERROR at line 2:  
ORA-00923: FROM keyword not found where expected  
此题要求选出列标题为Name和New Credit Limit，只有C满足。
A的Name应加双引号，原型输出
B/D语法错误

此题答案选C

13. View the Exhibit and examine the structure of the PRODUCTS table.
You need to generate a report in the following format:
CATEGORIES
5MP Digital Photo Camera's category is Photo
Y Box's category is Electronics
Envoy Ambassador's category is Hardware
Which two queries would give the required output? (Choose two.) 
A. SELECT prod_name  q'''s category is '  prod_category CATEGORIES
FROM products;
B. SELECT prod_name  q'['s ]'category is '  prod_category CATEGORIES
FROM products;
C. SELECT prod_name  q'\'s\'   ' category is '  prod_category CATEGORIES
FROM products;
D. SELECT prod_name  q'<'s >'   'category is '  prod_category CATEGORIES
FROM products;
Answer: CD
答案解析：
在SQL字符串是以单引号作为分界符的，在字符串前面和后面各一个单引号。但是字符串中也能包含单引号，为了使语法分析器能够区分字符串中的单引号还是分界符。规定当字符串中出现单引号时，在其前面添加一个单引号作为区分。也就是说， 在单引号分隔的字符串中，两个连续的单引号''表示一个单引号字符。
sh@TEST1107> select '''' from dual;

'
-
'
四个连续单引号分界为： 
第一个单引号，字符串的开始分界符。
接下来连续的两个单引号，表示字符串的值（一个单引号）
第四个单引号，字符串的结束分界符。

sh@TEST1107> select 'today is ''FRIDAY''' from dual;

'TODAYIS''FRIDAY'
-----------------
today is 'FRIDAY'

在Oracle中，single-quote(‘)是一个表示字符串的关键字。所以在字符串中用两个”表示一个实际的单引号字符。所有才会有了上面第一条SQL的'today is ''FRIDAY'''。双引号“被识别为一个实际的的字符串。其实Oracle提供了一个Q-quote的表达式，用来简化SQL或PLSQL中字符串的表示。
sh@TEST1107>  select q'[today is ''FRIDAY'']' names from dual;

NAMES
-------------------
today is ''FRIDAY''

sh@TEST1107> select q'[today is 'FRIDAY']' names from dual;

NAMES
-----------------
today is 'FRIDAY'
看上面两个的差别可知，使用Q-quote的表达式，只需要将要表示的字符串用一对特殊字符括起来，这对字符必须一致。不一致会报错。
sh@TEST1107> select q'[today is 'FRIDAY'|' names from dual;
ERROR:
ORA-01756: quoted string not properly terminated

sh@TEST1107> select q'|today is 'FRIDAY'|' names from dual;

NAMES
-----------------
today is 'FRIDAY'

从以上实验来解答题中的答案。

A答案错误，使用‘作为特殊字符，is后面缺少单引号，应该为
sh@TEST1107> SELECT prod_name || q'''s category is ''|| prod_category CATEGORIES FROM products;

CATEGORIES
----------------------------------------------------------------------------------------------------
5MP Telephoto Digital Camera's category is Photo
17" LCD w/built-in HDTV Tuner's category is Peripherals and Accessories
Envoy 256MB - 40GB's category is Hardware
Y Box's category is Electronics
Mini DV Camcorder with 3.5" Swivel LCD's category is Photo

B. 错误。SELECT prod_name  q'['s ]'category is '  prod_category CATEGORIES FROM products;
category is ' 这里前面缺少一个单引号。缺少category is 开始的单引号。
应该为：
sh@TEST1107> SELECT prod_name || q'['s ]'||'category is '||prod_category CATEGORIES FROM products;

CATEGORIES
----------------------------------------------------------------------------------------------------
5MP Telephoto Digital Camera's category is Photo
17" LCD w/built-in HDTV Tuner's category is Peripherals and Accessories
Envoy 256MB - 40GB's category is Hardware
Y Box's category is Electronics


C. 正确SELECT prod_name  q'\'s\'   ' category is '  prod_category CATEGORIES FROM products;

sh@TEST1107> SELECT prod_name||  q'\'s\' ||  ' category is ' || prod_category CATEGORIES FROM products;

CATEGORIES
----------------------------------------------------------------------------------------------------
5MP Telephoto Digital Camera's category is Photo
17" LCD w/built-in HDTV Tuner's category is Peripherals and Accessories
Envoy 256MB - 40GB's category is Hardware
Y Box's category is Electronics


D. 正确SELECT prod_name  q'<'s >'   'category is '  prod_category CATEGORIES FROM products;


sh@TEST1107> SELECT prod_name || q'<'s >'  || 'category is ' || prod_category CATEGORIES FROM products;

CATEGORIES
----------------------------------------------------------------------------------------------------
5MP Telephoto Digital Camera's category is Photo
17" LCD w/built-in HDTV Tuner's category is Peripherals and Accessories
Envoy 256MB - 40GB's category is Hardware
Y Box's category is Electronics

注意，题中答案需要添加||来连接字符串。

14. Using the CUSTOMERS table,  you need to generate a report that shows 50% of each   credit 
amount in each income level. The report should NOT show any repeated credit amounts in each income 
level.  --each income  level中没有重复的credit amounts
Which  query would give the required result? 
A.
SELECT  cust_income_level, DISTINCT cust_credit_limit * 0.50    
AS "50% Credit Limit" 
FROM customers;
 
[sql] view plaincopyprint?
sh@TESTDB> SELECT  cust_income_level, DISTINCT cust_credit_limit * 0.50      
  2  AS "50% Credit Limit"   
  3  FROM customers;   
SELECT  cust_income_level, DISTINCT cust_credit_limit * 0.50  
                           *  
ERROR at line 1:  
ORA-00936: missing expression  

语法错误，DISTINCT不应该放在第二列，应该放在第一列中
[sql] view plaincopyprint?
sh@TESTDB> SELECT DISTINCT  cust_income_level,cust_credit_limit * 0.50  
  2  AS "50% Credit Limit"  
  3  FROM customers where rownum<6;  
  
CUST_INCOME_LEVEL              50% Credit Limit  
------------------------------ ----------------  
G: 130,000 - 149,999                       5500  
G: 130,000 - 149,999                       4500  
G: 130,000 - 149,999                       3500  
G: 130,000 - 149,999                        750  


B.
SELECT DISTINCT cust_income_level, DISTINCT cust_credit_limit * 0.50    
AS "50% Credit Limit" 
FROM customers;
 
同A，语法错误，DISTINCT不应该放在第二个
[sql] view plaincopyprint?
SELECT DISTINCT cust_income_level, DISTINCT cust_credit_limit * 0.50      
  2  AS "50% Credit Limit"   
  3  FROM customers;   
SELECT DISTINCT cust_income_level, DISTINCT cust_credit_limit * 0.50  
                                   *  
ERROR at line 1:  
ORA-00936: missing expression  

 

C.
SELECT DISTINCT cust_income_level   '   '  cust_credit_limit * 0.50 
AS "50% Credit Limit" 
FROM customers;
[sql] view plaincopyprint?
sh@TESTDB> SELECT DISTINCT cust_income_level   '   '  cust_credit_limit * 0.50   
  2  AS "50% Credit Limit"   
  3  FROM customers;   
SELECT DISTINCT cust_income_level   '   '  cust_credit_limit * 0.50  
                                    *  
ERROR at line 1:  
ORA-00923: FROM keyword not found where expected  

这道题愿意为用' '连接两个列，可能用错，应为||来连接，不过DISTINCT的位置 对的
[sql] view plaincopyprint?
sh@TESTDB> SELECT DISTINCT cust_income_level || cust_credit_limit * 0.50  
  2  AS "50% Credit Limit"   
  3  FROM customers where rownum<6;  
  
50% Credit Limit  
----------------------------------------------------------------------  
G: 130,000 - 149,999750  
G: 130,000 - 149,9994500  
G: 130,000 - 149,9993500  
G: 130,000 - 149,9995500  
 
D.
SELECT cust_income_level ' ' cust_credit_limit * 0.50 AS "50% Credit Limit" 
FROM customers
D没有满足NOT show any repeated的条件。
 
此题答案C

15. View the Exhibit and examine the data in the CUSTOMERS table.  
Evaluate the following query: 
SQL> SELECT cust_name AS "NAME", cust_credit_limit/2 AS MIDPOINT,MIDPOINT+100 AS "MAX 
LOWER LIMIT" 
FROM customers; 
The above query produces an error on execution. 
What is the reason for the error? 
A. An alias cannot be used in an expression. 
B. The a lias NAME should not be enclosed with in double quotation marks . 
C. The MIDPOINT+100 expression  gives an error because  CUST_CREDIT_LIMIT contains NULL 
values. 
D.  The  a  lias  MIDPOINT  should  be  enclosed  with  in  double  quotation  marks   for  the 
CUST_CREDIT_LIMIT/2 expression .
 
[sql] view plaincopyprint?
sh@TESTDB> SELECT cust_name AS "NAME", cust_credit_limit/2 AS MIDPOINT,MIDPOINT+100 AS "MAX   
  2  LOWER LIMIT"   
  3  FROM customers;   
SELECT cust_name AS "NAME", cust_credit_limit/2 AS MIDPOINT,MIDPOINT+100 AS "MAX  
                                                            *  
ERROR at line 1:  
ORA-00904: "MIDPOINT": invalid identifier  

报错，select中不应该用别名来用在表达式里
 
[sql] view plaincopyprint?
sh@TESTDB> SELECT cust_last_name AS "NAME", cust_credit_limit/2 AS MIDPOINT,cust_credit_limit/2+100 AS "MAX LOWER LIMIT"  
  2  FROM customers WHERE ROWNUM<6;  
  
NAME                                                 MIDPOINT MAX LOWER LIMIT  
-------------------------------------------------- ---------- ---------------  
Ruddy                                                     750             850  
Ruddy                                                    3500            3600  
Ruddy                                                    5500            5600  
Ruddy                                                     750             850  
Ruddy                                                    4500            4600  

此题答案选A
   
   